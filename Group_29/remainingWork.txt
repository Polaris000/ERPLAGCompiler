

<<module compute>>
1. takes input[a:integer, b:integer, c:integer];
2. returns [res_1:boolean, res_2_a:integer, res_2__b:real];
3. start
4. declare b:boolean;
5. res_2_a:= -(a*b-c/5);
6. res_2__b:= ((res_2_a + a)*12+22.34E-2)/13;
7. b := a <=  b AND c >= a OR  a<0 AND false;
8. res_1:= (true AND c==b)OR(b>0 AND (a<=c));
end

Here variable b is in input parameter and also declared in the local scope. So as you have mentioned in the class the local scope variable (b) will overshadow the input variable. So in lines 5, 7 and 8, the variable b should be of type boolean right? 
Yes, this is right.

Also if b  is considered to be of boolean type, then should lines 5 and 7 be type error, as in line 5 an integer (a) is being multiplied with boolean (b) and in line 7 integer (a) is being compared with boolean (b)?
Yes, this will be a type error.

For '==' and '!=' as in line 8  (c==b), should there be a type error as a boolean is being equated with an integer.
Yes, this will be a type error.

Line 6  should also be an error as  22.34E-2  is of type real and the rest of the variables are of integer type.
Yes, this will be a type error.
 
While giving type error do we need to provide for which variable or constant the error arises or we just need to mention that there is type error in line x?
Line number is important. You can decide the appropriate error message to be displayed on the console for the user.

As with the input variable, can an output variable be overshadowed by a variable which is declared in the local scope?
Let us not go for this. Do not declare the variable in your test case with the same name as that of the output parameter. There is no need to detect an error if a variable is declared so. 

Please let me know if the above explanation helps.
 